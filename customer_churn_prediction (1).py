# -*- coding: utf-8 -*-
"""Customer_Churn_prediction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JB81ZfK-Hvj-F3dTREf6nIHWXcXl5O7y

## Importing Libraries
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import sklearn
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder,OneHotEncoder,MinMaxScaler
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score,precision_score, recall_score
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier
from xgboost import XGBClassifier

"""# About the data

#### **Context**

Predict behavior to retain customers. You can analyze all relevant customer data and develop focused customer retention programs.

#### **Content**

Each row represents a customer, each column contains customer’s attributes described on the column Metadata.

#### **About columns :**

**customerID :** `Customer ID`

 **gender :** `Whether the customer is a male or a female`

  **SeniorCitizen :** `Whether the customer is a senior citizen or not (1, 0)`

  **Partner :** `Whether the customer has a partner or not (Yes, No)`

  **Dependents :** `Whether the customer has dependents or not (Yes, No)`

  **tenure :** `Number of months the customer has stayed with the company`

  **PhoneService :** `Whether the customer has a phone service or not (Yes, No)`

  **MultipleLines :** `Whether the customer has multiple lines or not (Yes, No, No phone service)`

  **InternetService :** `Customer’s internet service provider (DSL, Fiber optic, No)`

  **OnlineSecurity :** `Whether the customer has online security or not (Yes, No, No internet service)`

  **OnlineBackup :** `Whether the customer has online backup or not (Yes, No, No internet service)`

  **DeviceProtection :** `Whether the customer has device protection or not (Yes, No, No internet service)`

  
  **TechSupport :** `Whether the customer has tech support or not (Yes, No, No internet service)`

  **StreamingTV :** `Whether the customer has streaming TV or not (Yes, No, No internet service)`

  **StreamingMovies :** `Whether the customer has streaming movies or not (Yes, No, No internet service)`

  **Contract :** `The contract term of the customer (Month-to-month, One year, Two year)`

  **PaperlessBilling :** `Whether the customer has paperless billing or not (Yes, No)`

  **PaymentMethod :** `The customer’s payment method (Electronic check, Mailed check, Bank transfer (automatic), Credit card`

  **MonthlyCharges :** `The amount charged to the customer monthly`

   **TotalCharges :** `The total amount charged to the customer`

   **Churn :** `Whether the customer churned or not (Yes or No)`

## Importing dataset
"""

data = pd.read_csv('/content/WA_Fn-UseC_-Telco-Customer-Churn.csv')
data.head(3)

"""## Data Preprocessing"""

print('Number of Rows data have :',data.shape[0])
print('Number of Columns data have :',data.shape[1])

"""`checking Missing and Duplicate values in the data`"""

data.isnull().sum()

data.duplicated().sum()

data.info()

"""`Totalcharges are obejct data type so, fixing them`"""

data['TotalCharges'].unique()

"""`hence it gives string/charater as their values but it should be in integer format`"""

pd.to_numeric(data['TotalCharges'])

"""`here we get an error because TotalCharges column have ' ' empty string in it`

`To handle it we use 'coerce' function`
"""

# it will give the values that have space in the TotalCharges column
pd.to_numeric(data['TotalCharges'],errors='coerce')

# this code give null/empty value in column that w're looking for
data[pd.to_numeric(data['TotalCharges'],errors='coerce').isnull()]

# another method to find the empty value
data[data['TotalCharges'] == ' ']

"""`Droping these 11 rows`"""

# consider only those rows and in which TotalCharges are not empty and store it into a new DataFrame named as 'df'
df = data[data['TotalCharges'] != ' ']

df.info()

"""`Now converting TotalCharges to numeric`"""

df['TotalCharges'] = pd.to_numeric(df['TotalCharges'])

df.TotalCharges.dtypes

"""`Checking uniques value in all the columns`"""

for column in df:
  print(f'{column}\n{df[column].unique()}\n')

"""`Since deleting customerID because it won't help us to give any prediction it's just useless for now.`"""

df.drop(columns='customerID',inplace=True)

df.head(5)

"""`Since we analyze all the insights in the 'Customer_Churn_Analysis_Python' go check it out to understand and see the insights from it`

`we're just diving toward 'Machine Learning' part to build our model that will predict the churn`

## Data Cleaning

` Again checking uniques value in all the columns`
"""

for column in df:
  print(f'{column}\n{df[column].unique()}\n')

"""`Creating a function that will return only categorical columns`"""

def cat_col(df):
  for column in df:
    if df[column].dtypes == 'object':
      print(f'{column}\n{df[column].unique()}\n')

cat_col(df)

"""`Firstly we change 'No internet service' and 'No phone service' as 'No' beacuse it's just the same for that model`"""

df.replace('No internet service','No',inplace=True)
df.replace('No phone service','No',inplace=True)

cat_col(df)

"""`Now, we have to convert this 'Yes' and 'No' into numbers, because machine learning model only understand numbers`

`Approach 1 : we can do this by only one line of code in pandas : df.replace({'Yes': 1,'No':0},inplace=True) for all the yes_no_columns`

`But we're solving machine learning problem so we use machine learning approach which is 'Label Encoding' and 'OneHotEncoding'`

`LabelEncoder`

`LabelEncoding coverts the following column that we given to them into 'Yes' : 1 and 'No' : 0`
"""

le = LabelEncoder()
oe = OneHotEncoder(sparse=False)

df['Churn']= le.fit_transform(df['Churn'])

df['Churn'].unique()

"""`OneHotEncoder`"""

one_hot_encoding_col = [['gender','Partner','Dependents','PhoneService','MultipleLines','InternetService',
                        'OnlineSecurity','OnlineBackup','DeviceProtection','TechSupport','StreamingTV',
                        'StreamingMovies','Contract','PaperlessBilling','PaymentMethod']]

df['gender'] = oe.fit_transform(df[['gender']])
df['Partner'] = oe.fit_transform(df[['Partner']])
df['Dependents'] = oe.fit_transform(df[['Dependents']])
df['PhoneService'] = oe.fit_transform(df[['PhoneService']])
df['MultipleLines'] = oe.fit_transform(df[['MultipleLines']])
df['InternetService'] = oe.fit_transform(df[['InternetService']])
df['OnlineSecurity'] = oe.fit_transform(df[['OnlineSecurity']])
df['OnlineBackup'] = oe.fit_transform(df[['OnlineBackup']])
df['DeviceProtection'] = oe.fit_transform(df[['DeviceProtection']])
df['TechSupport'] = oe.fit_transform(df[['TechSupport']])
df['StreamingTV'] = oe.fit_transform(df[['StreamingTV']])
df['StreamingMovies'] = oe.fit_transform(df[['StreamingMovies']])
df['Contract'] = oe.fit_transform(df[['Contract']])
df['PaperlessBilling'] = oe.fit_transform(df[['PaperlessBilling']])
df['PaymentMethod'] = oe.fit_transform(df[['PaymentMethod']])

df['gender'].unique()

"""`transforming numerical column and getting all values of them into the range of '0-1'`

`Now, we have to fix 'Mothly','Total' charges and 'tenure' column because machine learning model perform well when we give same range of value to it so we had to convert these values into 1's and 0's format`

`In order to do that we're using 'MinMaxScaler' from sklearn`
"""

mi = MinMaxScaler()

df['TotalCharges'] = mi.fit_transform(df[['TotalCharges']])
df['MonthlyCharges'] = mi.fit_transform(df[['MonthlyCharges']])
df['tenure'] = mi.fit_transform(df[['tenure']])

# let's see the column values after transforming
for column in df:
  print(f'{column}\n{df[column].unique()}\n')

"""`Now, we're ready to build our model`"""

X = df.drop(columns=['Churn'])
y = df['Churn']

def model_scorer(model_name,model):

    output=[]

    output.append(model_name)

    X_train,X_test,y_train,y_test = train_test_split(X,y,test_size=0.20,random_state=42,stratify=y)

    model.fit(X_train,y_train)

    y_pred = model.predict(X_test)

    output.append(accuracy_score(y_test,y_pred))

    output.append(precision_score(y_test,y_pred))

    output.append(recall_score(y_test,y_pred))

    return output

model_dict={
    'log':LogisticRegression(),
    'decision_tree':DecisionTreeClassifier(),
    'random_forest':RandomForestClassifier(),
    'XGB':XGBClassifier()

}

model_output=[]
for model_name,model in model_dict.items():
    model_output.append(model_scorer(model_name,model))

model_output

df.head(4)

"""`Now let's creating a new data frame which store our predicted values so, that we can use that for our predictions`

`We're using 'LogisticRegression' as our model because it perform best among all of the other`
"""

lr = LogisticRegression()

lr.fit(X_train,y_train)

prediction = lr.predict(df)

# consider only those rows and in which TotalCharges are not empty and store it into a new DataFrame named as 'df'
data = data[data['TotalCharges'] != ' ']

data['predicted_churn'] = prediction

data

"""`Replacing 1 : Yes , 0 : No`"""

data['predicted_churn'].replace({1:'Yes',0:'No'},inplace=True)

"""`Creating a 'csv' for further analysis`"""

data.to_csv('predicted_churn.csv', index=False)



data['Churn'].value_counts()

data['predicted_churn'].value_counts()

data[['Churn','predicted_churn']].value_counts()









"""`Traing our data as random forest`"""

df1 = df.copy()

X = df1.drop(columns=['Churn'])
y = df1['Churn']

X_train,X_test,y_train,y_test = train_test_split(X,y,test_size=0.2,random_state=42)

rf = RandomForestClassifier(n_estimators=100,random_state=42)

rf.fit(X_train,y_train)

y_pred = rf.predict(X_test)

accuracy_score(y_pred,y_test)

importance = rf.feature_importances_
inci = np.argsort(importance)[::-1]

sns.barplot(x=importance[inci],y=X.columns[inci])

df2 = df.copy()

df2 = df2[['StreamingMovies','Contract','tenure','SeniorCitizen','PaymentMethod','PaperlessBilling']]

X = df2
y = df['Churn']

X_train,X_test,y_train,y_test = train_test_split(X,y,test_size=0.2,random_state=42)

rf = RandomForestClassifier(n_estimators=100,random_state=42)

rf.fit(X_train,y_train)

y_pred = rf.predict(X_test)

accuracy_score(y_pred,y_test)

